<!doctype html>
<title>GOVOR_U_TEKST</title>

<head>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta charset="utf-8">
	<!-- 
		DBJ: u ovoj stranici se ne koristi jQuery
		<script src="./jquery.min.js"></script>
	-->
	<style>
		html,
		body {
			background-color: #efefef;
		}

		body {
			font: 1.2em arial;
		}

		output {
			display: block;
		}

		#info {
			/* width: 100%; */
			display: block;
			border: 4px solid gray;
			margin: 2%;
			padding: 1%;
			height: 120 px;
			font: 14px monospace;
		}
	</style>
</head>

<body id="body">

	<div id="info"></div>

	<script>

		/// official spec is here: https://wicg.github.io/speech-api/#speechreco-sectionF
		/// I was using this as KB: https://bensonruan.com/voice-to-text-with-chrome-web-speech-api/

		onload = function () {

			if ('webkitSpeechRecognition' in window) {
				// speech recognition API supported
			} else {
				alert("speech recognition API is not supported on this browser");
				return ;
			}

			/// DBJ: usage: "1".paddingLeft("000")
			/*
			ECMAScript 2017 adds a padStart method to the String prototype. 
			This method will pad a string with spaces to a given length. 
			This method also takes an optional string that will be used instead of spaces for padding.

			'abc'.padStart(10);         // "       abc"
			'abc'.padStart(10, "foo");  // "foofoofabc"
			'abc'.padStart(6,"123465"); // "123abc"
			'abc'.padStart(8, "0");     // "00000abc"
			'abc'.padStart(1);          // "abc"

			A padEnd method was also added that works in the same manner.
			*/
			String.prototype.paddingLeft = function (paddingValue) {
				return String(paddingValue + this).slice(-paddingValue.length);
			};

			var info_block = document.querySelector("#info");
			var info_block_counter = 0;

			var info = function (message) {

				if (message === undefined) {
					info_block.innerHTML = ""; // clear 
					info_block_counter = 0;
				}
				else {
					var lineno = info_block_counter.toString().paddingLeft("000");
					info_block.innerHTML += (lineno + "> " + message + "<br/>");
					info_block_counter += 1;
				}
			}

			var speach_recognition_error_handler = function (event) {
                     info("speach_recognition_error_handler received:" + event.error );
			}

			var text = '';
			var respond = function (event) {

				/// DBJ: ovo resetuje `text`  
				text = '';
				for (var i = event.resultIndex; i < event.results.length; ++i) {
					var result = event.results[i];
					text += result[0].transcript;
					if (result.isFinal) {
						output.innerHTML += (text + '&nbsp;<br/>');
						document.body.style.backgroundColor = "white";
						output.style.color = 'blue';
						navigator.clipboard.writeText(text.toUpperCase());

						//location.reload();

					} else {
						// clearTimeout(myVar);
						// myVar = setInterval(myTimer, 5000);
						// output.innerHTML += (text + '&nbsp;');
					}
				}
			}

			var createOutput = function () {
				var output = document.createElement('output');
				output.style.color = 'red';
				output.style.border = "4px solid blue"; /// DBJ
				output.style.margin = "2%"; /// DBJ
				output.style.padding = "1%"; /// DBJ
				document.body.insertBefore(output, document.body.childNodes[0]); /// DBJ
				/// document.body.appendChild(output);
				return output;
			}

			var listen = function () {
				var recognition = new webkitSpeechRecognition();
				recognition.onerror =	speach_recognition_error_handler ;
				// recognition.continuous = false;
				// DBJ changed to true
				recognition.continuous = true;
				recognition.interimResults = true;
				//recognition.lang = 'en_GB';
				recognition.lang = 'sr';
				recognition.start();
				recognition.onresult = respond;
			}

			var output = createOutput();

			info("Output is ready");
			info("Listening...");

			listen();

			// window.resizeTo(620, 106); window.moveTo(0, 7);
			// SHOWdiv();

		} // eof onload()

	</script>

</body>